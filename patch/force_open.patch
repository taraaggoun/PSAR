diff --color -Nur linux-6.5.7/fs/Makefile linux/fs/Makefile
--- linux-6.5.7/fs/Makefile	2024-04-24 21:18:42.783576573 +0200
+++ linux/fs/Makefile	2024-04-24 21:27:02.634760581 +0200
@@ -7,7 +7,7 @@
 # 
 
 
-obj-y :=	open.o read_write.o file_table.o super.o \
+obj-y :=	opti_open.o open.o read_write.o file_table.o super.o \
 		char_dev.o stat.o exec.o pipe.o namei.o fcntl.o \
 		ioctl.o readdir.o select.o dcache.o inode.o \
 		attr.o bad_inode.o file.o filesystems.o namespace.o \
diff --color -Nur linux-6.5.7/fs/open.c linux/fs/open.c
--- linux-6.5.7/fs/open.c	2024-04-24 21:18:42.785576568 +0200
+++ linux/fs/open.c	2024-04-24 21:37:44.989984514 +0200
@@ -1388,6 +1388,9 @@
 }
 EXPORT_SYMBOL(file_open_root);
 
+pid_t open_pids[100] = {0};
+EXPORT_SYMBOL(open_pids);
+
 static long do_sys_openat2(int dfd, const char __user *filename,
 			   struct open_how *how)
 {
@@ -1412,6 +1415,13 @@
 		}
 	}
 	putname(tmp);
+	// Check if we want to do the optimization on the pid
+	for (int i = 0; i < 100; i++) {
+		if (open_pids[i] == 0)
+			break;
+		if (current->pid == open_pids[i])
+			mv_core();
+	}
 	return fd;
 }
 
diff --color -Nur linux-6.5.7/fs/opti_open.c linux/fs/opti_open.c
--- linux-6.5.7/fs/opti_open.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/opti_open.c	2024-04-24 21:45:42.824496565 +0200
@@ -0,0 +1,101 @@
+#include <linux/mm.h>
+#include <linux/fdtable.h>
+#include <linux/rcupdate.h>
+
+/**
+ * Get fdtable for current process
+*/
+static struct fdtable* get_fdtable(void)
+{
+	// Get process's files struct
+	struct files_struct *files = current->files;
+	if (!files) {
+		pr_err("Failed to get files_struct\n");
+		return NULL;
+	}
+
+	// Get process's fd table
+	struct fdtable *fdt;
+	rcu_read_lock();
+	fdt = files_fdtable(files);
+	rcu_read_unlock();
+
+	if (!fdt) {
+		pr_err("fd table NULL\n");
+		return NULL;
+	}
+	return fdt;
+}
+
+/**
+ * Retur the index of the max of the array
+*/
+static int max_tab(int *tab, int len) {
+	int max = tab[0];
+	for (int i = 1; i < len; i++)
+		if (tab[i] > tab[max])
+			max = i;
+	return max;
+}
+
+/**
+ * Add in the array all the pages in the index of the node where they are mapped
+*/
+static int get_core_fd(struct fdtable *fdt, int fd, int *tab, int len)
+{
+	struct file *file = NULL;
+	file = fdt->fd[fd];
+	if (file == NULL)
+		return -1;
+
+	struct address_space *mapping = file->f_inode->i_mapping;
+	if (xa_empty(&(mapping->i_pages)) || mapping->nrpages <= 0)
+		return -1;
+
+	xa_lock(&mapping->i_pages);
+	XA_STATE(xas, &mapping->i_pages, 0);
+
+	// Go throught all folio
+	struct folio *folio;
+	xas_for_each(&xas, folio, ULONG_MAX) {
+		// Add the number of pages in tab
+		tab[folio_nid(folio)] += folio_nr_pages(folio);
+	}
+	xa_unlock(&mapping->i_pages);
+	
+	return 0;
+}
+
+/**
+ * Get the core where we affect the thread
+*/
+static int get_core_pid(int *tab, int len)
+{
+	struct fdtable *fdt = get_fdtable();
+	if (fdt == NULL)
+		return -1;
+	for (int i = 3; i < fdt->max_fds; i++) {
+		if (get_core_fd(fdt, i, tab, len) == -1)
+			return -1;
+	}
+	return max_tab(tab, len);
+}
+
+/**
+ * Force the thread to go to the core with the most pages mapped
+*/
+void mv_core(void)
+{
+	cpumask_t cpu_mask = { 0 };
+	int tab[NR_CPUS] = { 0 };
+	
+	int core_id = get_core_pid(tab, NR_CPUS);
+	if (core_id == -1)
+		return;
+	cpumask_set_cpu(core_id, &cpu_mask);
+
+	// Assign the program to all the cores in the set
+	pr_info(" Go to core : %d\n", core_id);
+	if (sched_setaffinity(current->pid, &cpu_mask) == -1)
+		pr_info("Error on setaffinity\n");
+}
diff --color -Nur linux-6.5.7/include/linux/mm.h linux/include/linux/mm.h
--- linux-6.5.7/include/linux/mm.h	2024-04-24 21:18:42.787576562 +0200
+++ linux/include/linux/mm.h	2024-04-24 21:40:34.541545810 +0200
@@ -3922,4 +3922,5 @@
 
 #endif
 
+void mv_core(void);
 #endif /* _LINUX_MM_H */
